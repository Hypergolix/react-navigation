{"version":3,"sources":["createMemoryHistory.tsx"],"names":["createMemoryHistory","index","items","pending","interrupt","forEach","it","cb","history","id","window","state","findIndex","item","get","backIndex","path","i","push","slice","length","pushState","replace","replaceState","go","n","nextIndex","lastItemIndex","Promise","resolve","reject","done","interrupted","clearTimeout","timer","Error","title","document","ref","setTimeout","splice","onPopState","currentIndex","Math","max","last","pop","removeEventListener","addEventListener","listen","listener"],"mappings":"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","sourcesContent":["import type { NavigationState } from '@react-navigation/core';\r\nimport { nanoid } from 'nanoid/non-secure';\r\n\r\ntype HistoryRecord = {\r\n  // Unique identifier for this record to match it with window.history.state\r\n  id: string;\r\n  // Navigation state object for the history entry\r\n  state: NavigationState;\r\n  // Path of the history entry\r\n  path: string;\r\n};\r\n\r\nexport default function createMemoryHistory() {\r\n  let index = 0;\r\n  let items: HistoryRecord[] = [];\r\n\r\n  // Pending callbacks for `history.go(n)`\r\n  // We might modify the callback stored if it was interrupted, so we have a ref to identify it\r\n  const pending: { ref: unknown; cb: (interrupted?: boolean) => void }[] = [];\r\n\r\n  const interrupt = () => {\r\n    // If another history operation was performed we need to interrupt existing ones\r\n    // This makes sure that calls such as `history.replace` after `history.go` don't happen\r\n    // Since otherwise it won't be correct if something else has changed\r\n    pending.forEach((it) => {\r\n      const cb = it.cb;\r\n      it.cb = () => cb(true);\r\n    });\r\n  };\r\n\r\n  const history = {\r\n    get index(): number {\r\n      // We store an id in the state instead of an index\r\n      // Index could get out of sync with in-memory values if page reloads\r\n      const id = window.history.state?.id;\r\n\r\n      if (id) {\r\n        const index = items.findIndex((item) => item.id === id);\r\n\r\n        return index > -1 ? index : 0;\r\n      }\r\n\r\n      return 0;\r\n    },\r\n\r\n    get(index: number) {\r\n      return items[index];\r\n    },\r\n\r\n    backIndex({ path }: { path: string }) {\r\n      // We need to find the index from the element before current to get closest path to go back to\r\n      for (let i = index - 1; i >= 0; i--) {\r\n        const item = items[i];\r\n\r\n        if (item.path === path) {\r\n          return i;\r\n        }\r\n      }\r\n\r\n      return -1;\r\n    },\r\n\r\n    push({ path, state }: { path: string; state: NavigationState }) {\r\n      interrupt();\r\n\r\n      const id = nanoid();\r\n\r\n      // When a new entry is pushed, all the existing entries after index will be inaccessible\r\n      // So we remove any existing entries after the current index to clean them up\r\n      items = items.slice(0, index + 1);\r\n\r\n      items.push({ path, state, id });\r\n      index = items.length - 1;\r\n\r\n      // We pass empty string for title because it's ignored in all browsers except safari\r\n      // We don't store state object in history.state because:\r\n      // - browsers have limits on how big it can be, and we don't control the size\r\n      // - while not recommended, there could be non-serializable data in state\r\n      window.history.pushState({ id }, '', path);\r\n    },\r\n\r\n    replace({ path, state }: { path: string; state: NavigationState }) {\r\n      interrupt();\r\n\r\n      const id = window.history.state?.id ?? nanoid();\r\n\r\n      let index = items.findIndex(item => item.id === id)\r\n\r\n      if (!items.length || index < 0) {\r\n        items = [{ path, state, id }];\r\n        index = 0;\r\n      } else {\r\n        items[index] = { path, state, id };\r\n      }\r\n\r\n      window.history.replaceState({ id }, '', path);\r\n    },\r\n\r\n    // `history.go(n)` is asynchronous, there are couple of things to keep in mind:\r\n    // - it won't do anything if we can't go `n` steps, the `popstate` event won't fire.\r\n    // - each `history.go(n)` call will trigger a separate `popstate` event with correct location.\r\n    // - the `popstate` event fires before the next frame after calling `history.go(n)`.\r\n    // This method differs from `history.go(n)` in the sense that it'll go back as many steps it can.\r\n    go(n: number) {\r\n      interrupt();\r\n\r\n      // To guard against unexpected navigation out of the app we will assume that browser history is only as deep as the length of our memory\r\n      // history. If we don't have an item to navigate to then update our index and navigate as far as we can without taking the user out of the app.\r\n      const nextIndex = index + n;\r\n      const lastItemIndex = items.length - 1;\r\n      if (n < 0 && !items[nextIndex]) {\r\n        // Attempted to navigate beyond the first index. Negating the current index will align the browser history with the first item.\r\n        n = -index;\r\n        index = 0;\r\n      } else if (n > 0 && nextIndex > lastItemIndex) {\r\n        // Attempted to navigate past the last index. Calculate how many indices away from the last index and go there.\r\n        n = lastItemIndex - index;\r\n        index = lastItemIndex;\r\n      } else {\r\n        index = nextIndex;\r\n      }\r\n\r\n      if (n === 0) {\r\n        return;\r\n      }\r\n\r\n      // When we call `history.go`, `popstate` will fire when there's history to go back to\r\n      // So we need to somehow handle following cases:\r\n      // - There's history to go back, `history.go` is called, and `popstate` fires\r\n      // - `history.go` is called multiple times, we need to resolve on respective `popstate`\r\n      // - No history to go back, but `history.go` was called, browser has no API to detect it\r\n      return new Promise<void>((resolve, reject) => {\r\n        const done = (interrupted?: boolean) => {\r\n          clearTimeout(timer);\r\n\r\n          if (interrupted) {\r\n            reject(new Error('History was changed during navigation.'));\r\n            return;\r\n          }\r\n\r\n          // There seems to be a bug in Chrome regarding updating the title\r\n          // If we set a title just before calling `history.go`, the title gets lost\r\n          // However the value of `document.title` is still what we set it to\r\n          // It's just not displayed in the tab bar\r\n          // To update the tab bar, we need to reset the title to something else first (e.g. '')\r\n          // And set the title to what it was before so it gets applied\r\n          // It won't work without setting it to empty string coz otherwise title isn't changing\r\n          // Which means that the browser won't do anything after setting the title\r\n          const { title } = window.document;\r\n\r\n          window.document.title = '';\r\n          window.document.title = title;\r\n\r\n          resolve();\r\n        };\r\n\r\n        pending.push({ ref: done, cb: done });\r\n\r\n        // If navigation didn't happen within 100ms, assume that it won't happen\r\n        // This may not be accurate, but hopefully it won't take so much time\r\n        // In Chrome, navigation seems to happen instantly in next microtask\r\n        // But on Firefox, it seems to take much longer, around 50ms from our testing\r\n        // We're using a hacky timeout since there doesn't seem to be way to know for sure\r\n        const timer = setTimeout(() => {\r\n          const index = pending.findIndex((it) => it.ref === done);\r\n\r\n          if (index > -1) {\r\n            pending[index].cb();\r\n            pending.splice(index, 1);\r\n          }\r\n        }, 100);\r\n\r\n        const onPopState = () => {\r\n          const id = window.history.state?.id;\r\n          const currentIndex = items.findIndex((item) => item.id === id);\r\n\r\n          // Fix createMemoryHistory.index variable's value\r\n          // as it may go out of sync when navigating in the browser.\r\n          index = Math.max(currentIndex, 0);\r\n\r\n          const last = pending.pop();\r\n\r\n          window.removeEventListener('popstate', onPopState);\r\n          last?.cb();\r\n        };\r\n\r\n        window.addEventListener('popstate', onPopState);\r\n        window.history.go(n);\r\n      });\r\n    },\r\n\r\n    // The `popstate` event is triggered when history changes, except `pushState` and `replaceState`\r\n    // If we call `history.go(n)` ourselves, we don't want it to trigger the listener\r\n    // Here we normalize it so that only external changes (e.g. user pressing back/forward) trigger the listener\r\n    listen(listener: () => void) {\r\n      const onPopState = () => {\r\n        if (pending.length) {\r\n          // This was triggered by `history.go(n)`, we shouldn't call the listener\r\n          return;\r\n        }\r\n\r\n        listener();\r\n      };\r\n\r\n      window.addEventListener('popstate', onPopState);\r\n\r\n      return () => window.removeEventListener('popstate', onPopState);\r\n    },\r\n  };\r\n\r\n  return history;\r\n}\r\n"]}